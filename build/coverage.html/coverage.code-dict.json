{"/home/travis/build/npmtest/node-npmtest-node-workflow/test.js":"/* istanbul instrument in package npmtest_node_workflow */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-workflow/lib.npmtest_node_workflow.js":"/* istanbul instrument in package npmtest_node_workflow */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_node_workflow = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_node_workflow = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-node-workflow/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-node-workflow && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_node_workflow */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_node_workflow\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_node_workflow.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_node_workflow.rollup.js'] =\n            local.assetsDict['/assets.npmtest_node_workflow.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_node_workflow.__dirname + '/lib.npmtest_node_workflow.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-workflow/node_modules/node-workflow/lib/index.js":"// Copyright 2012 Pedro P. Candel <kusorbox@gmail.com>. All rights reserved.\n\nmodule.exports = {\n  Factory: function (backend) {\n    if (typeof (backend) !== 'object') {\n      throw new Error('backend must be an object');\n    }\n\n    var WorkflowBackend = require('./workflow-backend'),\n        WorkflowFactory = require('./workflow-factory');\n\n    if (!backend.constructor.super_ ||\n      backend.constructor.super_ !== WorkflowBackend)\n    {\n      throw new Error('backend must inherit from WorkflowBackend');\n    }\n\n    return new WorkflowFactory(backend);\n  },\n  Backend: function () {\n    var Backend = require('./workflow-in-memory-backend');\n    return new Backend();\n  },\n  API: function (config) {\n    if (typeof (config) !== 'object') {\n      throw new Error('config must be an object');\n    }\n\n    var API = require('./api');\n    return new API(config);\n  },\n  Runner: function (config) {\n    if (typeof (config) !== 'object') {\n      throw new Error('config must be an object');\n    }\n    var WorkflowRunner = require('./runner');\n    return new WorkflowRunner(config);\n  },\n  WorkflowBackend: require('./workflow-backend')\n};\n","/home/travis/build/npmtest/node-npmtest-node-workflow/node_modules/node-workflow/lib/workflow-backend.js":"// Copyright 2012 Pedro P. Candel <kusorbox@gmail.com>. All rights reserved.\n//\n// Abstract backend, intended to be inherited by real workflow backends\n// implementations\nvar WorkflowBackend = module.exports = function (config) {\n  this.config = config;\n};\n\nWorkflowBackend.prototype.init = function (callback) {\n  callback();\n};\n\nWorkflowBackend.prototype.quit = function (callback) {\n  callback();\n};\n\n// workflow - Workflow object\n// callback - f(err, workflow)\nWorkflowBackend.prototype.createWorkflow = function (workflow, callback) {\n  throw new Error('Backend.createWorkflow is not implemented');\n};\n\n// job - Job object\n// callback - f(err, job)\nWorkflowBackend.prototype.createJob = function (job, callback) {\n  throw new Error('Backend.createJob is not implemented');\n};\n\n// workflow - Workflow.uuid\nWorkflowBackend.prototype.getWorkflow = function (workflow, callback) {\n  throw new Error('Backend.getWorkflow is not implemented');\n};\n\n// job - Job.uuid\n// callback - f(err, job)\nWorkflowBackend.prototype.getJob = function (job, callback) {\n  throw new Error('Backend.getJob is not implemented');\n};\n\n// workflow - Workflow object. Workflow.uuid property used to verify record\n//            exists\n// callback - f(err, workflow)\nWorkflowBackend.prototype.updateWorkflow = function (workflow, callback) {\n  throw new Error('Backend.updateWorkflow is not implemented');\n};\n\n// Applied only to running jobs, to track progress\n// job - Job object. Job.uuid property used to verify record exists.\n// callback - f(err, job)\nWorkflowBackend.prototype.updateJob = function (job, callback) {\n  throw new Error('Backend.updateJob is not implemented');\n};\n\n// Update only the given Job property. Intendeed to prevent conflicts with\n// two sources updating the same job at the same time, but different properties\n// uuid - the job's uuid\n// prop - the name of the property to update\n// val - value to assign to such property\n// callback - f(err) called with error if something fails, otherwise with null.\nWorkflowBackend.prototype.updateJobProperty = function (\n  uuid,\n  prop,\n  val,\n  callback)\n{\n  throw new Error('Backend.updateJob is not implemented');\n};\n\n// workflow - the workflow object\n// callback - f(err, boolean)\nWorkflowBackend.prototype.deleteWorkflow = function (workflow, callback) {\n  throw new Error('Backend.deleteWorkflow is not implemented');\n};\n\n\n// Get a single job property\n// uuid - Job uuid.\n// prop - (String) property name\n// cb - callback f(err, value)\nWorkflowBackend.prototype.getJobProperty = function (uuid, prop, cb) {\n  throw new Error('Backend.getJobProperty is not implemented');\n};\n\n\n// job - the job object\n// callback - f(err) called with error in case there is a duplicated\n// job with the same target and same params\nWorkflowBackend.prototype.validateJobTarget = function (job, callback) {\n  throw new Error('Backend.validateJobTarget is not implemented');\n};\n\n// Job queue related methods:\n\n// Get the next queued job. When there is no next job callback will be called\n// with callback(null, null).\n// index - Integer, optional. When given, it'll get the job at index position\n//         (when not given, it'll return the job at position zero).\n// callback - f(err, job)\nWorkflowBackend.prototype.nextJob = function (index, callback) {\n  throw new Error('Backend.nextJob is not implemented');\n};\n\n// Lock a job, mark it as running by the given runner, update job status.\n// uuid - the job uuid (String)\n// runner_id - the runner identifier (String)\n// callback - f(err, job) callback will be called with error if something\n//            fails, otherwise it'll return the updated job using getJob.\nWorkflowBackend.prototype.runJob = function (uuid, runner_id, callback) {\n  throw new Error('Backend.runJob is not implemented');\n};\n\n// Unlock the job, mark it as finished, update the status, add the results\n// for every job's task.\n// job - the job object. It'll be saved to the backend with the provided\n//       properties.\n// callback - f(err, job) callback will be called with error if something\n//            fails, otherwise it'll return the updated job using getJob.\nWorkflowBackend.prototype.finishJob = function (job, callback) {\n  throw new Error('Backend.finishJob is not implemented');\n};\n\n// Queue a job which has been running; i.e, due to whatever the reason,\n// re-queue the job. It'll unlock the job, update the status, add the\n// results for every finished task so far ...\n// job - the job Object. It'll be saved to the backend with the provided\n//       properties to ensure job status persistence.\n// callback - f(err, job) callback will be called with error if something\n//            fails, otherwise it'll return the updated job using getJob.\nWorkflowBackend.prototype.queueJob = function (job, callback) {\n  throw new Error('Backend.queueJob is not implemented');\n};\n\n// Get the given number of queued jobs.\n// - start - Integer - Position of the first job to retrieve\n// - stop - Integer - Position of the last job to retrieve, _included_\n// - callback - f(err, jobs)\nWorkflowBackend.prototype.nextJobs = function (start, stop, callback) {\n  throw new Error('Backend.nextJobs is not implemented');\n};\n\n// Register a runner on the backend and report it's active:\n// - runner_id - String, unique identifier for runner.\n// - active_at - ISO String timestamp. Optional. If none is given, current time\n// - callback - f(err)\nWorkflowBackend.prototype.registerRunner = function (\n  runner_id,\n  active_at,\n  callback\n) {\n  throw new Error('Backend.registerRunner is not implemented');\n};\n\n// Report a runner remains active:\n// - runner_id - String, unique identifier for runner. Required.\n// - active_at - ISO String timestamp. Optional. If none is given, current time\n// - callback - f(err)\nWorkflowBackend.prototype.runnerActive = function (\n  runner_id,\n  active_at,\n  callback\n) {\n  throw new Error('Backend.runnerActive is not implemented');\n};\n\n// Get the given runner id details\n// - runner_id - String, unique identifier for runner. Required.\n// - callback - f(err, runner)\nWorkflowBackend.prototype.getRunner = function (runner_id, callback) {\n  throw new Error('Backend.getRunner is not implemented');\n};\n\n// Get all the registered runners:\n// - callback - f(err, runners)\nWorkflowBackend.prototype.getRunners = function (callback) {\n  throw new Error('Backend.getRunners is not implemented');\n};\n\n// Set a runner as idle:\n// - runner_id - String, unique identifier for runner\n// - callback - f(err)\nWorkflowBackend.prototype.idleRunner = function (runner_id, callback) {\n  throw new Error('Backend.getRunners is not implemented');\n};\n\n// Check if the given runner is idle\n// - runner_id - String, unique identifier for runner\n// - callback - f(boolean)\nWorkflowBackend.prototype.isRunnerIdle = function (runner_id, callback) {\n  throw new Error('Backend.isRunnerIdle is not implemented');\n};\n\n// Remove idleness of the given runner\n// - runner_id - String, unique identifier for runner\n// - callback - f(err)\nWorkflowBackend.prototype.wakeUpRunner = function (runner_id, callback) {\n  throw new Error('Backend.isRunnerIdle is not implemented');\n};\n\n// Get all jobs associated with the given runner_id\n// - runner_id - String, unique identifier for runner\n// - callback - f(err, jobs). `jobs` is an array of job's UUIDs.\n//   Note `jobs` will be an array, even when empty.\nWorkflowBackend.prototype.getRunnerJobs = function (runner_id, callback) {\n  throw new Error('Backend.getRunnerJobs is not implemented');\n};\n\n// Get all the workflows:\n// - callback - f(err, workflows)\nWorkflowBackend.prototype.getWorkflows = function (callback) {\n  throw new Error('Backend.getWorkflows is not implemented');\n};\n\n// Get all the jobs:\n// - execution - String, the execution status for the jobs to return.\n//               Return all jobs if no execution status is given.\n// - callback - f(err, jobs)\nWorkflowBackend.prototype.getJobs = function (execution, callback) {\n  throw new Error('Backend.getJobs is not implemented');\n};\n\n// Add progress information to an existing job:\n// - uuid - String, the Job's UUID.\n// - info - Object, {'key' => 'Value'}\n// - callback - f(err)\nWorkflowBackend.prototype.addInfo = function (uuid, info, callback) {\n  throw new Error('Backend.addInfo is not implemented');\n};\n\n// Get progress information from an existing job:\n// - uuid - String, the Job's UUID.\n// - callback - f(err, info)\nWorkflowBackend.prototype.getInfo = function (uuid, callback) {\n  throw new Error('Backend.getInfo is not implemented');\n};\n","/home/travis/build/npmtest/node-npmtest-node-workflow/node_modules/node-workflow/lib/api.js":"// Copyright 2012 Pedro P. Candel <kusorbox@gmail.com> All rights reserved.\nvar restify = require('restify'),\n    util = require('util'),\n    uuid = require('node-uuid'),\n    path = require('path'),\n    fs = require('fs'),\n    vm = require('vm'),\n    async = require('async'),\n    Logger = require('bunyan'),\n    Factory = require('../lib/index').Factory;\n\n\nvar API = module.exports = function (opts) {\n  if (typeof (opts) !== 'object') {\n    throw new TypeError('opts (Object) required');\n  }\n\n  if (typeof (opts.backend) !== 'object') {\n    throw new TypeError('opts.backend (Object) required');\n  }\n\n  if (typeof (opts.api) !== 'object') {\n    throw new TypeError('opts.api (Object) required');\n  }\n\n  if (!opts.logger) {\n    opts.logger = {};\n  }\n\n  opts.logger.name = 'workflow-api';\n  opts.logger.serializers = {\n    err: Logger.stdSerializers.err,\n    req: Logger.stdSerializers.req,\n    res: restify.bunyan.serializers.response\n  };\n\n  opts.logger.streams = opts.logger.streams || [ {\n    level: 'info',\n    stream: process.stdout\n  }];\n\n  this.log = opts.api.Logger = new Logger(opts.logger);\n\n  opts.api.name = opts.api.name || 'Workflow API';\n  opts.api.acceptable = ['application/json'];\n\n  if (!opts.api.port && !opts.api.path) {\n    opts.api.path = '/tmp/' + uuid();\n  }\n  this.opts = opts;\n\n  var Backend, factory, backend;\n  this.server = restify.createServer(opts.api);\n  Backend = require(opts.backend.module);\n  this.backend = backend = new Backend(opts.backend.opts);\n  factory = Factory(backend);\n\n  // Define path and versioned routes:\n  this.WORKFLOWS_PATH = '/workflows';\n  this.WORKFLOW_PATH = this.WORKFLOWS_PATH + '/:uuid';\n  this.WORKFLOWS_ROUTE = {\n    path: this.WORKFLOWS_PATH,\n    version: '0.1.0'\n  };\n  this.WORKFLOW_ROUTE = {\n    path: this.WORKFLOW_PATH,\n    version: '0.1.0'\n  };\n\n  this.JOBS_PATH = '/jobs';\n  this.JOB_PATH = this.JOBS_PATH + '/:uuid';\n  this.JOBS_ROUTE = {\n    path: this.JOBS_PATH,\n    version: '0.1.0'\n  };\n  this.JOB_ROUTE = {\n    path: this.JOB_PATH,\n    version: '0.1.0'\n  };\n  this.JOB_INFO_PATH = this.JOB_PATH + '/info';\n  this.JOB_INFO_ROUTE = {\n    path: this.JOB_INFO_PATH,\n    version: '0.1.0'\n  };\n  this.JOB_CANCEL_PATH = this.JOB_PATH + '/cancel';\n  this.JOB_CANCEL_ROUTE = {\n    path: this.JOB_CANCEL_PATH,\n    version: '0.1.0'\n  };\n\n\n  this.server.use(restify.acceptParser(this.server.acceptable));\n  this.server.use(restify.bodyParser());\n  this.server.use(restify.queryParser());\n\n  // Define handlers:\n  function listWorkflows(req, res, next) {\n    backend.getWorkflows(function (err, workflows) {\n      if (err) {\n        return next(new restify.InternalErrorError(err));\n      }\n      res.send(200, workflows);\n      return next();\n    });\n  }\n\n  function postWorkflow(req, res, next) {\n    var workflow = {},\n        wf_members = ['name', 'uuid', 'timeout', 'chain', 'onerror'],\n        error;\n\n    // Up to the user if want to identify the workflow with self.cooked uuid:\n    wf_members.forEach(function (p) {\n      if (req.params[p]) {\n        workflow[p] = req.params[p];\n      }\n    });\n\n    if (workflow.chain) {\n      workflow.chain.forEach(function (task, i, arr) {\n        if (!task.body) {\n          error = new restify.ConflictError('Task body is required');\n        }\n        task.body = vm.runInNewContext('(' + task.body + ')', {});\n        if (task.fallback) {\n          task.fallback = vm.runInNewContext('(' + task.fallback + ')', {});\n        }\n        workflow.chain[i] = task;\n      });\n    }\n\n    if (workflow.onerror) {\n      workflow.onerror.forEach(function (task, i, arr) {\n        if (!task.body) {\n          error = new restify.ConflictError('Task body is required');\n        }\n        task.body = vm.runInNewContext('(' + task.body + ')', {});\n        if (task.fallback) {\n          task.fallback = vm.runInNewContext('(' + task.fallback + ')', {});\n        }\n        workflow.onerror[i] = task;\n      });\n    }\n\n    if (error) {\n      return next(error);\n    }\n\n    return factory.workflow(workflow, function (err, result) {\n      if (err) {\n        return next(new restify.ConflictError(err));\n      }\n      res.header('Location', req.path + '/' + result.uuid);\n      res.status(201);\n      res.send(result);\n      return next();\n    });\n  }\n\n  function getWorkflow(req, res, next) {\n    backend.getWorkflow(req.params.uuid, function (err, workflow) {\n      if (err) {\n        if (err.match(/uuid/gi)) {\n          return next(new restify.ResourceNotFoundError(\n            'Workflow ' + req.params.uuid + ' not found'));\n        } else {\n          return next(new restify.InternalErrorError(err));\n        }\n      } else {\n        res.send(200, workflow);\n        return next();\n      }\n    });\n  }\n\n  function updateWorkflow(req, res, next) {\n    var error;\n\n    if (req.params.chain) {\n      req.params.chain.forEach(function (task) {\n        if (!task.body) {\n          error = new restify.ConflictError('Task body is required');\n        }\n      });\n    }\n\n    if (req.params.onerror) {\n      req.params.onerror.forEach(function (task) {\n        if (!task.body) {\n          error = new restify.ConflictError('Task body is required');\n        }\n      });\n    }\n\n    if (error) {\n      return next(error);\n    }\n\n    return backend.updateWorkflow(req.params, function (err, workflow) {\n      if (err) {\n        if (err === 'Workflow does not exist. Cannot Update.') {\n          return next(new restify.ResourceNotFoundError(\n            'Workflow ' + req.params.uuid + ' not found'));\n        } else {\n          return next(new restify.InternalErrorError(err));\n        }\n      }\n      res.send(200, workflow);\n      return next();\n    });\n  }\n\n  function deleteWorkflow(req, res, next) {\n    backend.getWorkflow(req.params.uuid, function (err, workflow) {\n      if (err) {\n        if (err.match(/uuid/gi)) {\n          return next(new restify.ResourceNotFoundError(\n            'Workflow ' + req.params.uuid + ' not found'));\n        } else {\n          return next(new restify.InternalErrorError(err));\n        }\n      } else {\n        return backend.deleteWorkflow(workflow, function (err, deleted) {\n          if (err) {\n            return next(new restify.InternalErrorError(err));\n          }\n\n          if (deleted) {\n            res.send(204);\n            return next();\n          } else {\n            return next(new restify.InternalErrorError(\n                'Cannot delete the workflow'));\n          }\n        });\n      }\n    });\n  }\n\n  function listJobs(req, res, next) {\n    var exec_values =\n      ['queued', 'failed', 'succeeded', 'running', 'canceled'],\n        cb = function (err, jobs) {\n          if (err) {\n            return next(new restify.InternalErrorError(err));\n          }\n          res.send(200, jobs);\n          return next();\n        };\n\n    if (req.params.execution) {\n      if (exec_values.indexOf(req.params.execution) === -1) {\n        return next(new restify.ConflictError(\n          'Execution must be one of queued, failed, ' +\n          'succeeded, canceled or running'));\n      } else {\n        return backend.getJobs(req.params.execution, cb);\n      }\n    } else {\n      return backend.getJobs(cb);\n    }\n  }\n\n  function postJob(req, res, next) {\n    var job = {\n      params: {}\n    };\n\n    Object.keys(req.params).forEach(function (p) {\n      if (['exec_after', 'workflow', 'target', 'uuid'].indexOf(p) !== -1) {\n        job[p] = req.params[p];\n      } else {\n        job.params[p] = req.params[p];\n      }\n    });\n\n    factory.job(job, function (err, result) {\n      if (err) {\n        return next(new restify.ConflictError(err));\n      }\n      res.header('Location', req.path + '/' + result.uuid);\n      res.status(201);\n      res.send(result);\n      return next();\n    });\n  }\n\n  function getJob(req, res, next) {\n    backend.getJob(req.params.uuid, function (err, job) {\n      if (err) {\n        if (err.match(/does not exist/gi)) {\n          return next(new restify.ResourceNotFoundError(\n            'Job ' + req.params.uuid + ' not found'));\n        } else {\n          return next(new restify.InternalErrorError(err));\n        }\n      } else {\n        res.send(200, job);\n        return next();\n      }\n    });\n  }\n\n  function getInfo(req, res, next) {\n    backend.getInfo(req.params.uuid, function (err, info) {\n      if (err) {\n        if (err === 'Job does not exist. Cannot get info.') {\n          return next(new restify.ResourceNotFoundError(err));\n        } else {\n          return next(new restify.InternalErrorError(err));\n        }\n      } else {\n        res.send(200, info);\n        return next();\n      }\n    });\n  }\n\n  function postInfo(req, res, next) {\n    var info = {};\n    Object.keys(req.params).forEach(function (p) {\n      if (p !== 'uuid') {\n        info[p] = req.params[p];\n      }\n    });\n    backend.addInfo(req.params.uuid, info, function (err) {\n      if (err) {\n        if (err === 'Job does not exist. Cannot Update.') {\n          return next(new restify.ResourceNotFoundError(err));\n        } else {\n          return next(new restify.ConflictError(err));\n        }\n      } else {\n        res.send(200);\n        return next();\n      }\n    });\n  }\n\n  function cancelJob(req, res, next) {\n    backend.getJob(req.params.uuid, function (err, job) {\n      if (err) {\n        if (err.match(/does not exist/gi)) {\n          return next(new restify.ResourceNotFoundError(\n            'Job ' + req.params.uuid + ' not found'));\n        } else {\n          return next(new restify.InternalErrorError(err));\n        }\n      } else if (job.execution === 'succeeded' || job.execution === 'failed') {\n        return next(new restify.ConflictError(\n          'Finished jobs cannot be canceled'));\n      } else {\n        return backend.updateJobProperty(\n          job.uuid,\n          'execution',\n          'canceled',\n          function (err) {\n            if (err) {\n              return next(new restify.InternalErrorError(err));\n            }\n            job.execution = 'canceled';\n            res.send(200, job);\n            return next();\n          });\n      }\n    });\n  }\n  // --- Routes\n  // Workflows:\n  this.server.get(this.WORKFLOWS_ROUTE, listWorkflows);\n  this.server.head(this.WORKFLOWS_ROUTE, listWorkflows);\n  this.server.post(this.WORKFLOWS_ROUTE, postWorkflow);\n  // Workflow:\n  this.server.get(this.WORKFLOW_ROUTE, getWorkflow);\n  this.server.head(this.WORKFLOW_ROUTE, getWorkflow);\n  this.server.put(this.WORKFLOW_ROUTE, updateWorkflow);\n  this.server.del(this.WORKFLOW_ROUTE, deleteWorkflow);\n  // Jobs:\n  this.server.get(this.JOBS_ROUTE, listJobs);\n  this.server.head(this.JOBS_ROUTE, listJobs);\n  this.server.post(this.JOBS_ROUTE, postJob);\n  // Job:\n  this.server.get(this.JOB_ROUTE, getJob);\n  this.server.head(this.JOB_ROUTE, getJob);\n  // Cancel job:\n  this.server.post(this.JOB_CANCEL_ROUTE, cancelJob);\n  // Job status info:\n  this.server.get(this.JOB_INFO_ROUTE, getInfo);\n  this.server.head(this.JOB_INFO_ROUTE, getInfo);\n  this.server.post(this.JOB_INFO_ROUTE, postInfo);\n};\n\n\nAPI.prototype.init = function (callback) {\n  var self = this,\n      port_or_path = (!self.opts.api.port) ?\n                     self.opts.api.path :\n                     self.opts.api.port;\n  self.backend.init(function () {\n    self.log.info('API backend initialized');\n    self.server.listen(port_or_path, function () {\n      self.log.info('%s listening at %s', self.server.name, self.server.url);\n      callback();\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-node-workflow/node_modules/node-workflow/lib/child.js":"// Copyright 2012 Pedro P. Candel <kusorbox@gmail.com> All rights reserved.\n//\n// Child process to be \"forked\" from task-runner.js.\n//\nvar util = require('util'),\n    WorkflowTaskRunner = require('./task-runner'),\n    wf_task_runner;\n\n// Every possible situation finishes this way, notifying parent process about\n// execution results:\nfunction notifyParent(msg) {\n  process.send(msg);\n\n  setTimeout(function () {\n    process.exit();\n  }, 100);\n}\n\n\n\n// This is the only way we have for communication from the parent process.\n//\n// Main case:\n// - We receive a message from parent including the 'task' to run and the 'job'\n//   object itself. Optionally, this object may also contain a 'sandbox' object\n//   and 'trace' enabled.\n// Side case:\n// - We receive a message to finish the task \"as is\" due to a \"finish task now\"\n//   call.\nprocess.on('message', function (msg) {\n  if (msg.job && msg.task) {\n    try {\n      wf_task_runner = new WorkflowTaskRunner(msg);\n      wf_task_runner.runTask(notifyParent);\n    } catch (e) {\n      notifyParent({\n        error: e.message\n      });\n    }\n  } else if (msg.cmd && msg.cmd === 'cancel') {\n    // Cancel message received from job runner\n    wf_task_runner.canceled = true;\n  } else {\n    // Finally, notify parent about unknown messages\n    notifyParent({\n      error: 'unknown message'\n    });\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-node-workflow/node_modules/node-workflow/lib/task-runner.js":"// Copyright 2012 Pedro P. Candel <kusorbox@gmail.com>. All rights reserved.\nvar util = require('util'),\n    vm = require('vm');\n\nvar TimeoutError = function (msg) {\n  this.name = 'TimeoutError';\n  this.message = msg || 'Timeout Error';\n};\n\nTimeoutError.prototype = new Error();\nTimeoutError.prototype.constructor = TimeoutError;\n\n// Run a single task.\n// - opts (Object) required options to run the task:\n//   - job (Object) the job current task is part of.\n//   - task (Object) the task to run.\n//   - sandbox (Object) the sandbox to pass to the VM where the task run\n//     in the form:\n//       { 'module_global_var_name': 'node-module-name' }\n//   - trace (Boolean) when set to true, it will return information\n//     about the methods called while running the task, and the number of\n//     retries for task.body.\n// Will return an object with the following information:\n// - job (Object) the job object updated with any modification the task\n//   may need to realize. Note this is the only way of communication between\n//   tasks.\n// - result (String) information about task results.\n// - error (String) when an error has happened, descriptive information.\n// - cmd (String) next command workflow should run after this task. Right now\n//   one of 'run', 'error' or 'queue'.\nvar WorkflowTaskRunner = module.exports = function (opts) {\n\n  if (typeof (opts) !== 'object') {\n    throw new TypeError('opts (Object) required');\n  }\n\n  if (typeof (opts.job) !== 'object') {\n    throw new TypeError('opts.job (Object) required');\n  }\n\n  if (typeof (opts.task) !== 'object') {\n    throw new TypeError('opts.task (Object) required');\n  }\n\n  var sandbox = {\n    setTimeout: global.setTimeout,\n    clearTimeout: global.clearTimeout,\n    setInterval: global.setInterval,\n    clearInterval: global.clearInterval\n  };\n\n  if (opts.sandbox) {\n    if (typeof (opts.sandbox) !== 'object') {\n      throw new TypeError('opts.sandbox must be an Object');\n    } else {\n      Object.keys(opts.sandbox).forEach(function (mod) {\n        sandbox[mod] = require(opts.sandbox[mod]);\n      });\n    }\n  }\n\n  this.job = opts.job;\n  this.uuid = opts.task.uuid;\n  // Number of times to attempt the task\n  this.retry = opts.task.retry || 1;\n  // Timeout for the task, when given\n  this.timeout = (opts.task.timeout * 1000) || null;\n  // First, wrap into try/catch, since it may be invalid JavaScript:\n  try {\n    this.body = vm.runInNewContext('(' + opts.task.body + ')', sandbox);\n  } catch (e) {\n    throw new TypeError('opt.task.body (String) must be a Function source');\n  }\n\n  // Even if it is valid JavaScript code, we need it to be a function:\n  if (typeof (this.body) !== 'function') {\n    throw new TypeError('opt.task.body (String) must be a Function source');\n  }\n\n  try {\n    this.fallback = (!opts.task.fallback) ? null :\n      vm.runInNewContext('(' + opts.task.fallback + ')', sandbox);\n  } catch (err) {\n    throw new TypeError(\n      'opt.task.fallback (String) must be a Function source');\n  }\n\n  if (this.fallback && typeof (this.fallback) !== 'function') {\n    throw new TypeError(\n      'opt.task.fallback (String) must be a Function source');\n  }\n\n  // Number of already run retries:\n  this.retries = 0;\n  this.retryTimedOut = false;\n  // Placeholder for timeout identifiers:\n  this.taskTimeoutId = null;\n  this.taskFallbackTimeoutId = null;\n  // Need to keep a reference to timeout exeception listener\n  this.timeoutListener = null;\n  // When trace is enabled, we need to retrieve this info:\n  this.stack = {\n    retries: 0,\n    methods: []\n  };\n  // Return trace information?\n  this.trace = opts.trace || false;\n  // Received cancelation message from parent?\n  this.canceled = false;\n};\n\n\n// Run the task. As many retries as required, invoke fallback if\n// necessary. Send back a message with info about results, error,\n// the job object itself to communicate with other tasks and a command\n// to let WorkflowJobRunner how to proceed.\n//\n// - callback - f(message)\n//\n// - message is the same than self.message, and will be composed of the\n//   following members:\n//   - result (String) any information the tasks want to save into the\n//     proper result chain.\n//   - err (String) if there is an error, it'll be here as an string.\n//   - job (Object) the job object itself, without this task's results\n//     appended, so we can pass job properties to the following tasks on the\n//     chain.\n//   - cmd (String) depending on results and the task itself, a clue for the\n//     WorkflowJobRunner to decide what to do next. These values will be one of\n//     'run', 'error', 'queue'. (In the future we may also implement 'pause' to\n//     let the runner set a timeout to continue execution).\nWorkflowTaskRunner.prototype.runTask = function (callback) {\n  var self = this;\n\n  self.stack.methods.push('runTask');\n\n  // Go for it!\n  return self.retryTask(callback);\n};\n\n\nWorkflowTaskRunner.prototype.retryTask = function (cb) {\n  var self = this;\n\n  self.timeoutListener = function (err) {\n    if (err.name === 'TimeoutError') {\n      return self.onRetryError('task timeout error', cb);\n    } else {\n      throw err;\n    }\n  };\n  self.stack.retries = self.retries += 1;\n  self.stack.methods.push('retryTask');\n\n  // Set the task timeout when given:\n  if (self.timeout) {\n    self.clearTaskTimeoutId();\n    // Task timeout must be in seconds:\n    self.taskTimeoutId = setTimeout(function () {\n      self.stack.methods.push('taskTimeoutId');\n      self.retryTimedOut = true;\n      process.on('uncaughtException', self.timeoutListener);\n      throw new TimeoutError('task timeout error');\n    }, self.timeout);\n  }\n\n  self.body(self.job, function (err, res) {\n    if (self.retryTimedOut) {\n      self.retryTimedOut = false;\n      return null;\n    }\n\n    self.stack.methods.push('task.body callback');\n\n    // Reached callback from task body, clear the taskTimeout first:\n    self.clearTaskTimeoutId();\n    // Task invokes callback with an error message:\n    if (err) {\n      // A task can re-queue a workflow:\n      if (err === 'queue') {\n        return cb(self.formatResults({\n          result: (res) ? res : 'OK',\n          error: 'queue'\n        }));\n      }\n      return self.onRetryError(err, cb);\n    } else {\n      // All good calling the task body, let's save the results and move\n      // to next task:\n      return cb(self.formatResults({\n        result: (res) ? res : 'OK'\n      }));\n    }\n  });\n\n};\n\n// A retry may fail either due to a task timeout or just a task failure:\nWorkflowTaskRunner.prototype.onRetryError = function (err, cb) {\n  var self = this;\n\n  self.stack.methods.push('onRetryError');\n  self.clearTaskTimeoutId();\n\n  // If job sent a cancelation message, stop here:\n  if (self.canceled) {\n    return cb(self.formatResults({\n      error: 'cancel',\n      cmd: 'cancel'\n    }));\n  }\n\n  // If we are not at the latest retry, try again:\n  if (self.retries < self.retry) {\n    return self.retryTask(cb);\n  } else {\n    // We are at the latest retry, check if the task has a 'fallback':\n    if (self.fallback) {\n      self.timeoutListener = function (err) {\n        if (err.name === 'TimeoutError') {\n          return cb(self.formatResults({\n            error: 'task timeout error'\n          }));\n        } else {\n          throw err;\n        }\n      };\n\n      // Set the task timeout when given also for fallback:\n      if (self.timeout) {\n        if (self.taskFallbackTimeoutId) {\n          process.removeListener('uncaughtException', self.timeoutListener);\n          clearTimeout(self.taskFallbackTimeoutId);\n          self.taskFallbackTimeoutId = null;\n        }\n        // Task timeout must be in seconds:\n        self.taskFallbackTimeoutId = setTimeout(function () {\n          self.stack.methods.push('taskFallbackTimeoutId');\n          process.on('uncaughtException', self.timeoutListener);\n          throw new TimeoutError('task timeout error');\n        }, self.timeout);\n      }\n\n      return self.fallback(err, self.job, function (error, result) {\n        if (self.taskFallbackTimeoutId) {\n          process.removeListener('uncaughtException', self.timeoutListener);\n          clearTimeout(self.taskFallbackTimeoutId);\n          self.taskFallbackTimeoutId = null;\n        }\n\n        self.stack.methods.push('task.fallback callback');\n\n        // If even the error handler returns an error, we have to\n        // bubble it up:\n        if (error) {\n          return cb(self.formatResults({\n            error: error\n          }));\n        }\n        // If the 'fallback' handler fixed the error, let's return\n        // success despite of body failure:\n        return cb(self.formatResults({\n          result: (result) ? result : 'OK'\n        }));\n      });\n    } else {\n      // Latest retry and task 'fallback' is not defined, fail the task\n      // save the error and bubble up:\n      return cb(self.formatResults({\n        error: err\n      }));\n    }\n  }\n};\n\n\nWorkflowTaskRunner.prototype.formatResults = function (msg) {\n  var self = this;\n\n  if (!msg.result) {\n    msg.result = '';\n  }\n\n  if (!msg.error) {\n    msg.error = '';\n  }\n\n  if (!msg.cmd) {\n    if (msg.error === '') {\n      msg.cmd = 'run';\n    } else {\n      msg.cmd = (msg.error === 'queue') ? 'queue' : 'error';\n    }\n  }\n\n  msg.job = self.job;\n  if (self.trace) {\n    msg.trace = self.stack;\n  }\n  return msg;\n};\n\n\nWorkflowTaskRunner.prototype.clearTaskTimeoutId = function () {\n  var self = this;\n  if (self.taskTimeoutId) {\n    process.removeListener('uncaughtException', self.timeoutListener);\n    clearTimeout(self.taskTimeoutId);\n    self.taskTimeoutId = null;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-node-workflow/node_modules/node-workflow/lib/job-runner.js":"// Copyright 2012 Pedro P. Candel <kusorbox@gmail.com>. All rights reserved.\nvar util = require('util'),\n    events = require('events'),\n    fork = require('child_process').fork,\n    async = require('async'),\n    WorkflowTaskRunner = require('./task-runner');\n\n\n// Run the given job. Optionally, can pass sandbox object for the 'task' VM\n// and enable trace to retrieve task trace information.\n// - opts (Object) with the following members:\n//\n// - runner (Object) insteance of the runner running this job. Required to\n//   notify the runner about child processes spawned/finished. Required.\n// - backend (Object) instance of the backend used. Required.\n// - job (Object) the job to run. Required.\n// - sandbox (Object) VM's sandbox for task (see WorkflowTaskRunner). Optional.\n// - trace (Boolean) retrieve trace information from tasks. Optional.\nvar WorkflowJobRunner = module.exports = function (opts) {\n  events.EventEmitter.call(this);\n  if (typeof (opts) !== 'object') {\n    throw new TypeError('opts (Object) required');\n  }\n\n  if (typeof (opts.runner) !== 'object') {\n    throw new TypeError('opts.runner (Object) required');\n  }\n\n  if (typeof (opts.backend) !== 'object') {\n    throw new TypeError('opts.backend (Object) required');\n  }\n\n  if (typeof (opts.job) !== 'object') {\n    throw new TypeError('opts.job (Object) required');\n  }\n\n  if (opts.sandbox && typeof (opts.sandbox) !== 'object') {\n    throw new TypeError('opts.sandbox must be an Object');\n  }\n\n  this.runner = opts.runner;\n  this.job = opts.job;\n  this.backend = opts.backend;\n  this.sandbox = opts.sandbox || {};\n  this.trace = opts.trace || false;\n  this.log = opts.runner.log.child({job_uuid: opts.job.uuid}, true);\n\n  if (!util.isDate(this.job.exec_after)) {\n    this.job.exec_after = new Date(this.job.exec_after);\n  }\n\n  if (!this.job.chain) {\n    this.job.chain = [];\n  }\n\n  if (!this.job.chain_results) {\n    this.job.chain_results = [];\n  }\n\n  if (this.job.onerror && !this.job.onerror_results) {\n    this.job.onerror_results = [];\n  }\n\n  this.timeout = null;\n  if (this.job.timeout) {\n    this.timeout = ((this.job.elapsed) ?\n      (this.job.timeout - this.job.elapsed) :\n      this.job.timeout) * 1000;\n  }\n  // Did we consumed the job's total timeout?\n  this.jobTimedOut = false;\n  // Need to keep elapsed time in msecs\n  this.started = null;\n  // pointer to child process forked by runTask\n  this.child = null;\n  // Properties of job object which a task should not be allowed to modify:\n  this.frozen_props = [\n    'chain', 'chain_results', 'onerror', 'onerror_results',\n    'exec_after', 'timeout', 'elapsed', 'uuid', 'workflow_uuid',\n    'name', 'execution'\n  ];\n  // We \"phone home\" periodically to detect if our job has been canceled while\n  // running. If so, we set this to true:\n  this.canceled = false;\n  // Id for the \"phone home\" interval:\n  this.phoneHomeId = null;\n};\n\nutil.inherits(WorkflowJobRunner, events.EventEmitter);\n\n// Run the workflow within a timeout which, in turn, will call tasks in chain\n// within their respective timeouts when given:\n// Arguments:\n// - callback: f(err) - Used to send final job results\nWorkflowJobRunner.prototype.run = function (callback) {\n  var self = this;\n  // Check for job status. If it's cancelled, send child process a message\n  // to stop retrying task. Once task is done, stop running chain and return\n  // a response to runner calling callback.\n  self.phoneHomeId = setInterval(function () {\n    self.backend.getJobProperty(\n      self.job.uuid,\n      'execution',\n      function (err, val) {\n        if (err) {\n          // Backend error, nonsensical to keep doing nothing\n          self.emit('end', 'backend error', callback);\n        } else if (val === 'canceled') {\n          self.canceled = true;\n          if (self.child) {\n            self.child.send({\n              cmd: 'cancel'\n            });\n            clearInterval(self.phoneHomeId);\n            self.phoneHomeId = null;\n          }\n          // If we don't have a child, no need to do nothing, we're either\n          // finishing or about to fork the child. Just wait for the next\n          // iteration to send the message.\n        }\n        return;\n      });\n  }, self.runner.run_interval);\n\n  self.on('error', function (err, callback) {\n    // We're already running the onerror chain, do not retry again!\n    if (self.failed) {\n      self.emit('end', err, callback);\n    } else {\n      self.failed = true;\n      if (self.job.onerror && util.isArray(self.job.onerror)) {\n        self.runChain(self.job.onerror, 'onerror_results', callback);\n      } else {\n        self.emit('end', err, callback);\n      }\n    }\n  });\n\n  self.on('end', function (err, callback) {\n    if (err) {\n      self.failure = err;\n      if (err === 'queue') {\n        self.job.execution = 'queued';\n      } else if (err === 'cancel') {\n        self.job.execution = 'canceled';\n      } else {\n        self.job.execution = 'failed';\n      }\n    } else {\n      self.job.execution = 'succeeded';\n    }\n    if (self.phoneHomeId) {\n      clearInterval(self.phoneHomeId);\n      self.phoneHomeId = null;\n    }\n    return self.saveJob(callback);\n  });\n\n  // Keep track of time:\n  self.started = new Date().getTime();\n  self.runChain(self.job.chain, 'chain_results', callback);\n};\n\n\n// Run the given chain of tasks\n// Arguments:\n// - chain: the chain of tasks to run.\n// - chain_results: the name of the job property to append current chain\n//   results. For main `chain` it'll be `job.chain_results`; for `onerror`\n//   branch, it'll be `onerror_results` and so far.\n// - callback: f(err)\nWorkflowJobRunner.prototype.runChain = function (\n  chain,\n  chain_results,\n  callback)\n{\n  var self = this, timeoutId, chain_to_run;\n\n  if (self.timeout) {\n    timeoutId = setTimeout(function () {\n      // Execution of everything timed out, have to abort running tasks and run\n      // the onerror chain.\n      clearTimeout(timeoutId);\n      if (self.child) {\n        process.kill(self.child._pid, 'SIGTERM');\n      }\n      // If it's already failed, what it's timing out is the 'onerror' chain.\n      // We don't wanna run it again.\n      if (!self.failed) {\n        self.job[chain_results].push({\n          error: 'workflow timeout',\n          result: ''\n        });\n        self.backend.updateJobProperty(\n          self.job.uuid,\n          chain_results,\n          self.job[chain_results],\n          function (err) {\n            if (err) {\n              self.emit('end', 'backend error', callback);\n            }\n            self.emit('error', 'workflow timeout', callback);\n          });\n      } else {\n        self.job.onerror_results.push({\n          error: 'workflow timeout',\n          result: ''\n        });\n        self.backend.updateJobProperty(\n          self.job.uuid,\n          chain_results,\n          self.job.onerror_results,\n          function (err) {\n            if (err) {\n              self.emit('end', 'backend error', callback);\n            }\n            self.emit('end', 'workflow timeout', callback);\n          });\n      }\n    }, self.timeout);\n  }\n\n  if (self.job[chain_results].length) {\n    chain_to_run = chain.slice(\n      self.job[chain_results].length, chain.length);\n  } else {\n    chain_to_run = chain;\n  }\n\n  async.forEachSeries(chain_to_run, function (task, async_cb) {\n    // Job may have been re-queued. If that's the case, we already have\n    // results for some tasks: restart from the task right after the one\n    // which re-queued the workflow.\n    self.runTask(task, chain_results, async_cb);\n  }, function (err) {\n    // Whatever happened here, we are timeout done.\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n\n    if (err) {\n      // If we are cancelating job, we want to avoid running \"onerror\" branch\n      if (err === 'cancel') {\n        self.emit('end', 'cancel', callback);\n      } else {\n        self.emit('error', err, callback);\n      }\n    } else {\n      // All tasks run successful. Need to report information so, we rather\n      // emit 'end' and delegate into another function\n      self.emit('end', null, callback);\n    }\n  });\n};\n\n\nWorkflowJobRunner.prototype.runTask = function (task, chain, cb) {\n  var self = this,\n      task_start = new Date().toISOString();\n  self.child = fork(__dirname + '/child.js');\n  self.onChildUp();\n  // Message may contain either only 'error' member, or also 'cmd',\n  // 'result' and 'trace'.\n  self.child.on('message', function (msg) {\n    self.log.info('Got a message from child process');\n    self.log.trace(msg);\n    // Save the results into the result chain + update on the backend.\n    var res = {\n      result: msg.result,\n      error: msg.error,\n      started_at: task_start,\n      finished_at: new Date().toISOString()\n    };\n    // If the task added/updated any property to the job, let's get it\n    if (msg.job) {\n      Object.keys(msg.job).forEach(function (p) {\n        if (self.frozen_props.indexOf(p) === -1) {\n          self.job[p] = msg.job[p];\n        }\n      });\n    }\n\n    if (self.trace && msg.trace) {\n      res.trace = msg.trace;\n    }\n    self.job[chain].push(res);\n    self.backend.updateJobProperty(\n      self.job.uuid,\n      chain,\n      self.job[chain],\n      function (err) {\n        // If we canceled the job and got a reply from the running task we\n        // want to stop execution ASAP:\n        if (self.canceled) {\n          return cb('cancel');\n        }\n        // Backend error\n        if (err) {\n          return cb(err);\n        } else if (msg.error) {\n          // Task error\n          return cb(msg.error);\n        } else {\n          // All good:\n          return cb(null);\n        }\n      });\n  });\n  self.child.on('exit', function (code) {\n    self.onChildExit();\n  });\n\n  self.child.send({\n    task: task,\n    job: self.job,\n    sandbox: self.sandbox,\n    trace: self.trace\n  });\n};\n\nWorkflowJobRunner.prototype.onChildUp = function () {\n  var self = this;\n  if (self.child) {\n    self.child._pid = self.child.pid;\n    self.runner.childUp(self.job.uuid, self.child._pid);\n  }\n};\n\nWorkflowJobRunner.prototype.onChildExit = function () {\n  var self = this;\n  if (self.child) {\n    self.runner.childDown(self.job.uuid, self.child._pid);\n    self.child = null;\n  }\n};\n\n// - callback - f(err)\nWorkflowJobRunner.prototype.saveJob = function (callback) {\n  var self = this;\n  self.job.elapsed = (new Date().getTime() - self.started) / 1000;\n  // Decide what to do with the Job depending on its execution status:\n  if (\n    self.job.execution === 'failed' ||\n    self.job.execution === 'succeeded' ||\n    self.job.execution === 'canceled') {\n    self.log.trace('Finishing job ...');\n    return self.backend.finishJob(self.job, function (err, job) {\n      if (err) {\n        return callback(err);\n      }\n      return callback(null, job);\n    });\n  } else if (self.job.execution === 'queued') {\n    self.log.trace('Re queueing job ...');\n    return self.backend.queueJob(self.job, function (err, job) {\n      if (err) {\n        return callback(err);\n      }\n      return callback(null, job);\n    });\n  } else {\n    self.log.error('Unknown job execution status ' + self.job.execution);\n    return callback('unknown job execution status ' + self.job.execution);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-node-workflow/node_modules/node-workflow/lib/runner.js":"// Copyright 2012 Pedro P. Candel <kusorbox@gmail.com> All rights reserved.\nvar util = require('util'),\n    uuid = require('node-uuid'),\n    fs = require('fs'),\n    path = require('path'),\n    async = require('async'),\n    Logger = require('bunyan'),\n    WorkflowJobRunner = require('./job-runner');\n\n// - opts - configuration options:\n//    - identifier: Unique identifier for this runner.\n//    - forks: Max number of child processes to fork at the same time.\n//    - run_interval: Check for new jobs every 'run_interval' seconds.\n//                    (By default, every 2 minutes).\n//    - sandbox: Collection of node modules to pass to the sandboxed tasks\n//               execution. Object with the form:\n//               {\n//                  'module_global_var_name': 'node-module-name'\n//               }\n//               By default, only the global timeouts are passed to the tasks\n//               sandbox.\nvar WorkflowRunner = module.exports = function (opts) {\n  if (typeof (opts) !== 'object') {\n    throw new TypeError('opts (Object) required');\n  }\n\n  if (typeof (opts.backend) !== 'object') {\n    throw new TypeError('opts.backend (Object) required');\n  }\n\n  if (typeof (opts.runner) !== 'object') {\n    opts.runner = {};\n  }\n\n  var Backend = require(opts.backend.module);\n  this.backend = new Backend(opts.backend.opts);\n  this.identifier = opts.runner.identifier || null;\n  this.forks = opts.runner.forks || 10;\n  this.run_interval = (opts.runner.run_interval || 2) * 1000;\n  this.interval = null;\n  this.shutting_down = false;\n  this.child_processes = [];\n  this.sandbox = opts.runner.sandbox || {};\n  this.trace = opts.runner.trace || false;\n\n  if (!opts.logger) {\n    opts.logger = {};\n  }\n\n  opts.logger.name = 'workflow-runner';\n  opts.logger.serializers = {\n    err: Logger.stdSerializers.err\n  };\n\n  opts.logger.streams = opts.logger.streams || [ {\n    level: 'info',\n    stream: process.stdout\n  }];\n\n  opts.logger.runner_uuid = this.identifier;\n\n  this.log = new Logger(opts.logger);\n};\n\nWorkflowRunner.prototype.init = function (callback) {\n  var self = this,\n      series = [];\n  // Using async.series we can kind of write this sequentially and run some\n  // methods only when needed:\n\n  // 1) We need an unique identifier for this runner, also something\n  //    human friendly to identify the runner from a bunch of them would be\n  //    helpful.\n  if (!self.identifier) {\n    series.push(function (cb) {\n      self.getIdentifier(function (err, uuid) {\n        if (err) {\n          return cb(err);\n        }\n        self.identifier = uuid;\n        // Not that we really care about the return value here, anyway:\n        return cb(null, uuid);\n      });\n    });\n  }\n  // The runner will register itself on the backend, with its unique id.\n  series.push(function (cb) {\n    self.backend.registerRunner(self.identifier, function (err) {\n      if (err) {\n        return cb(err);\n      }\n      return cb(null, null);\n    });\n  });\n  // 2) On init, the runner will check for any job flagged as running with\n  //    the runner identifier. This means a previous failure so, first thing\n  //    will be take care of such failure.\n  //    NOTE: It would be desirable to \"hide\" the next queued Job to the\n  //    other runners when we fetch it for the current one.\n  self.backend.init(function () {\n    async.series(series, function (err, results) {\n      // Note we don't care at all about the results.\n      if (err) {\n        return callback(err);\n      }\n      return callback();\n    });\n  });\n};\n\n// Wait for children to finish, do not began any other child process.\n// Call callback on done.\nWorkflowRunner.prototype.quit = function (callback) {\n  var self = this;\n  self.shutting_down = true;\n  clearInterval(self.interval);\n  if (Object.keys(self.child_processes).length > 0) {\n    process.nextTick(function () {\n      self.quit(callback);\n    });\n  } else {\n    callback();\n  }\n};\n\n// This is the main runner method, where jobs execution takes place.\n// Every call to this method will result into a child_process being forked.\nWorkflowRunner.prototype.runJob = function (job, callback) {\n  var self = this,\n  wf_job_runner = new WorkflowJobRunner({\n    runner: self,\n    backend: self.backend,\n    job: job,\n    trace: self.trace,\n    sandbox: self.sandbox\n  });\n  wf_job_runner.run(callback);\n};\n\nWorkflowRunner.prototype.getIdentifier = function (callback) {\n  var cfg_file = path.resolve(__dirname, '../workflow-indentifier');\n\n  path.exists(cfg_file, function (exist) {\n    if (exist) {\n      fs.readFile(cfg_file, 'utf-8', function (err, data) {\n        if (err) {\n          return callback(err);\n        }\n        return callback(null, data);\n      });\n    } else {\n      var id = uuid();\n      fs.writeFile(cfg_file, id, 'utf-8', function (err) {\n        if (err) {\n          return callback(err);\n        }\n        return callback(null, id);\n      });\n    }\n  });\n};\n\nWorkflowRunner.prototype.runNow = function (job) {\n  return (new Date().getTime() >= new Date(job.exec_after).getTime());\n};\n\n// Just in case we need to kill it without leaving child processes around:\nWorkflowRunner.prototype.kill = function (callback) {\n  var self = this;\n  self.shutting_down = true;\n  clearInterval(self.interval);\n  if (Object.keys(self.child_processes).length > 0) {\n    Object.keys(self.child_processes).forEach(function (p) {\n      process.kill(p, 'SIGKILL');\n    });\n    self.child_processes = [];\n  }\n  if (callback) {\n    callback();\n  }\n};\n\n\nWorkflowRunner.prototype.run = function () {\n  var self = this,\n  // Queue worker. Tries to run a job, including \"hiding\" it from other\n  // runners:\n  worker = function (uuid, callback) {\n    self.backend.getJob(uuid, function (err, job) {\n      if (err) {\n        callback(err);\n      }\n\n      if (self.runNow(job)) {\n        self.backend.runJob(uuid, self.identifier, function (err, job) {\n          if (err) {\n            callback(err);\n          }\n\n          if (self.trace) {\n            console.time('JOB ' + job.uuid);\n          }\n          self.runJob(job, function (err) {\n            if (self.trace) {\n              console.timeEnd('JOB ' + job.uuid);\n            }\n            if (err) {\n              callback(err);\n            }\n            callback();\n          });\n        });\n      }\n    });\n  },\n  // We keep a queue with concurrency limit where we'll be pushing new jobs\n  queue = async.queue(worker, self.forks);\n\n  self.interval = setInterval(function () {\n    self.backend.runnerActive(self.identifier, function (err) {\n      if (err) {\n        self.log.error(err, 'Error reporting runner activity');\n        return;\n      }\n      self.backend.isRunnerIdle(self.identifier, function (idle) {\n        if (idle === false) {\n          async.parallel({\n            // Fetch stale jobs from runners which stopped reporting\n            // activity and cancel them:\n            stale_jobs: function (cb) {\n              self.staleJobs(function (err, jobs) {\n                if (err) {\n                  self.log.error(err, 'Error fetching stale jobs');\n                  // We will not stop even on error:\n                  return cb(null, null);\n                }\n                return async.forEach(jobs, function (uuid, fe_cb) {\n                  self.backend.updateJobProperty(\n                    uuid, 'execution', 'canceled',\n                    function (err) {\n                      if (err) {\n                        return fe_cb(err);\n                      }\n                      return self.backend.getJob(uuid, function (err, job) {\n                        if (err) {\n                          return fe_cb(err);\n                        }\n                        return self.backend.finishJob(job, function (err, job) {\n                          if (err) {\n                            return fe_cb(err);\n                          }\n                          self.log.info('Stale Job ' + job.uuid + ' canceled');\n                          return fe_cb(null);\n                        });\n                      });\n                    });\n                }, function (err) {\n                  return cb(null, null);\n                });\n              });\n            },\n            // Fetch jobs to process.\n            fetch_jobs: function (cb) {\n              var fetch = self.forks - Object.keys(self.child_processes).length;\n              self.backend.nextJobs(0, fetch - 1, function (err, jobs) {\n                // Error fetching jobs\n                if (err) {\n                  self.log.error(err, 'Error fetching jobs');\n                  // We will not stop even on error:\n                  return cb(null, null);\n                }\n                // No queued jobs\n                if (!jobs) {\n                  self.log.info('No jobs queued');\n                  return cb(null, null);\n                }\n                // Got jobs, let's see if we can run them:\n                jobs.forEach(function (job) {\n                  queue.push(job, function (err) {\n                    // Called once queue worker finished processing the job\n                    if (err) {\n                      self.log.error(err, 'Error running job');\n                    }\n                    self.log.info('Job with uuid ' + job + ' ran successfully');\n                  });\n                });\n                return cb(null, null);\n              });\n\n            }\n          }, function (err, results) {\n            return;\n          });\n        } else {\n          self.log.info('Runner idle.');\n        }\n      });\n    });\n  }, self.run_interval);\n};\n\n\nWorkflowRunner.prototype.childUp = function (job_uuid, child_pid) {\n  var self = this;\n  self.child_processes[child_pid] = job_uuid;\n};\n\nWorkflowRunner.prototype.childDown = function (job_uuid, child_pid) {\n  var self = this;\n  delete self.child_processes[child_pid];\n};\n\n// Check for inactive runners.\n// \"Inactive runner\" - a runner with latest status report older than\n//  3 times the runners' run_interval.\n//  - callback - f(err, runners): `err` always means backend error.\n//    `runners` will be an array, even empty.\nWorkflowRunner.prototype.inactiveRunners = function (callback) {\n  var self = this,\n      inactiveRunners = [];\n  self.backend.getRunners(function (err, runners) {\n    if (err) {\n      return callback(err);\n    }\n    Object.keys(runners).forEach(function (id) {\n      var outdated = new Date().getTime() - (self.run_interval * 3000);\n      if (\n        id !== self.identifier &&\n        new Date(runners[id]).getTime() < outdated) {\n        inactiveRunners.push(id);\n      }\n    });\n    return callback(null, inactiveRunners);\n  });\n};\n\n\n// Check for \"stale\" jobs, i.e, associated with inactive runners.\n// - callback(err, jobs): `err` means backend error.\n//   `jobs` will be an array, even empty. Note this will be an\n//   array of jobs UUIDs, so they can be canceled.\nWorkflowRunner.prototype.staleJobs = function (callback) {\n  var self = this,\n      staleJobs = [];\n  self.inactiveRunners(function (err, runners) {\n    if (err) {\n      return callback(err);\n    }\n    if (runners.length === 0) {\n      return callback(null, staleJobs);\n    } else {\n      return async.forEach(runners, function (runner, cb) {\n        self.backend.getRunnerJobs(runner, function (err, jobs) {\n          if (err) {\n            cb(err);\n          }\n          staleJobs = staleJobs.concat(jobs);\n          cb();\n        });\n      }, function (err) {\n        if (err) {\n          return callback(err);\n        }\n        return callback(null, staleJobs);\n      });\n    }\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-node-workflow/node_modules/node-workflow/lib/workflow-factory.js":"// Copyright 2012 Pedro P. Candel <kusorbox@gmail.com>. All rights reserved.\nvar uuid = require('node-uuid'),\n    util = require('util');\n\nvar WorkflowFactory = module.exports = function (backend) {\n  this.backend = backend;\n};\n\n// Create a workflow and store it on the backend\n//\n// - opts - the workflow object properties:\n//   - name: string workflow name, uniqueness enforced.\n//   - timeout: integer, acceptable time, in seconds, to run the wf.\n//     (60 minutes if nothing given). Also, the Boolean `false` can be used\n//     to explicitly create a workflow without a timeout.\n//   - chain: An array of Tasks to run.\n//   - onerror: An array of Tasks to run in case `chain` fails.\n// - callback - function(err, workflow)\n//\n// Every Task can have the following members:\n//   - name - string task name, optional.\n//   - body - function(job, cb) the task main function. Required.\n//   - fallback: function(err, job, cb) a function to run in case `body` fails\n//     Optional.\n//   - retry: Integer, number of attempts to run the task before try `fallback`\n//     Optional. By default, just one retry.\n//   - timeout: Integer, acceptable time, in seconds, a task execution should\n//     take, before fail it with timeout error. Optional.\n//\nWorkflowFactory.prototype.workflow = function (opts, callback) {\n  var self = this,\n      wf = opts || {};\n\n  function validateTask(task, cb) {\n    var p;\n\n    if (!task.body) {\n      return cb('Task \"body\" is required');\n    }\n\n    if (typeof (task.body) !== 'function') {\n      return cb('Task \"body\" must be a function');\n    }\n\n    if (!task.uuid) {\n      task.uuid = uuid();\n    }\n\n    // Ensure that if task.fallback is given, it's a function\n    if (task.fallback && typeof (task.fallback) !== 'function') {\n      return cb('Task \"fallback\" must be a function');\n    }\n\n    for (p in task) {\n      if (typeof (task[p]) === 'function') {\n        task[p] = task[p].toString();\n      }\n    }\n    return task;\n  }\n\n  if (!wf.name) {\n    return callback('Workflow \"name\" is required');\n  }\n\n  if (wf.chain && (\n        typeof (wf.chain) !== 'object' ||\n        typeof (wf.chain.length) === 'undefined')) {\n    return callback('Workflow \"chain\" must be an array');\n  }\n\n  if (!wf.chain) {\n    wf.chain = [];\n  }\n\n  if (!wf.uuid) {\n    wf.uuid = uuid();\n  }\n\n  if (wf.onError) {\n    wf.onerror = wf.onError;\n    delete wf.onError;\n  }\n\n  if (wf.onerror && (\n        typeof (wf.onerror) !== 'object' ||\n        typeof (wf.onerror.length) === 'undefined')) {\n    return callback('Workflow \"onerror\" must be an array');\n  }\n\n  wf.chain.forEach(function (task, i, arr) {\n    wf.chain[i] = validateTask(task, callback);\n  });\n\n  if (wf.onerror) {\n    wf.onerror.forEach(function (task, i, arr) {\n      wf.onerror[i] = validateTask(task, callback);\n    });\n  }\n\n  if (typeof (wf.timeout) !== 'number') {\n    wf.timeout = 3600;\n  } else if (wf.timeout === 0) {\n    delete wf.timeout;\n  }\n\n  return self.backend.createWorkflow(wf, function (err, result) {\n    if (err) {\n      return callback(err);\n    } else {\n      return callback(null, wf);\n    }\n  });\n};\n\n\n// Create a queue a Job from the given Workflow:\n//\n// - opts - the Job object workflow and extra arguments:\n//   - workflow - (required) UUID of Workflow object to create the job from.\n//   - params - (opt) JSON object, parameters to pass to the job during exec\n//   - target - (opt) String, Job's target, used to ensure that we don't\n//              queue two jobs with the same target and params at once.\n//   - exec_after - (opt) ISO 8601 Date, delay job execution after the\n//                  given timestamp (execute from now when not given).\n// - callback - f(err, job)\nWorkflowFactory.prototype.job = function (opts, callback) {\n  var self = this,\n      job = { execution: 'queued', chain_results: []};\n\n  if (!opts.workflow) {\n    return callback('\"opts.workflow\" is required');\n  }\n\n  return self.backend.getWorkflow(opts.workflow, function (err, wf) {\n    var p;\n    if (err) {\n      return callback(err);\n    }\n\n    if (Object.keys(wf).length === 0) {\n      return callback('Cannot create a job from an unexisting workflow');\n    }\n\n    if (wf.chain.length === 0) {\n      return callback('Cannot queue a job from a workflow without any task');\n    }\n\n    for (p in wf) {\n      if (p !== 'uuid') {\n        job[p] = wf[p];\n      } else {\n        job.workflow_uuid = wf.uuid;\n      }\n    }\n\n    job.exec_after = opts.exec_after || new Date().toISOString();\n    job.params = opts.params || {};\n\n    if (!job.uuid) {\n      job.uuid = uuid();\n    }\n\n    if (opts.target) {\n      job.target = opts.target;\n    }\n\n    return self.backend.validateJobTarget(job, function (err) {\n      if (err) {\n        return callback(err);\n      } else {\n        return self.backend.createJob(job, function (err, results) {\n          if (err) {\n            return callback(err);\n          } else {\n            return callback(null, job);\n          }\n        });\n      }\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-node-workflow/node_modules/node-workflow/lib/workflow-in-memory-backend.js":"// Copyright 2012 Pedro P. Candel <kusorbox@gmail.com>. All rights reserved.\n\nvar util = require('util'),\n    async = require('async'),\n    WorkflowBackend = require('./workflow-backend');\n\nvar sprintf = util.format;\n\nvar Backend = module.exports = function (config) {\n  WorkflowBackend.call(this);\n  this.config = config;\n  this.workflows = null;\n  this.jobs = null;\n  this.runners = null;\n  this.queued_jobs = null;\n};\n\nutil.inherits(Backend, WorkflowBackend);\n\n// You'd think the language would provide this...\n// This method assumes an acyclic graph.\nvar deepCopy = function (obj) {\n  switch (typeof (obj)) {\n  case 'object':\n    if (obj === null) {\n      return null;\n    } else {\n      var clone, i;\n      if (typeof (obj.length) === 'number') {\n        clone = [];\n        for (i = obj.length - 1; i >= 0; i -= 1) {\n          clone[i] = deepCopy(obj[i]);\n        }\n        return clone;\n      } else {\n        clone = {};\n        for (i in obj) {\n          clone[i] = deepCopy(obj[i]);\n        }\n      }\n      return clone;\n    }\n  case 'string':\n    return '' + obj;\n  default:\n    return obj;\n  }\n};\n\nBackend.prototype.init = function (callback) {\n  var self = this;\n  self.workflows = {};\n  self.jobs = {};\n  self.runners = {};\n  self.queued_jobs = [];\n  callback();\n};\n\n// Callback - f(err);\nBackend.prototype.quit = function (callback) {\n  callback();\n};\n\n\n// workflow - Workflow object\n// callback - f(err, workflow)\nBackend.prototype.createWorkflow = function (workflow, callback) {\n  var self = this;\n  if (self._wfNames().indexOf(workflow.name) !== -1) {\n    return callback('Workflow.name must be unique. A workflow with name \"' +\n      workflow.name + '\" already exists');\n  } else {\n    self.workflows[workflow.uuid] = deepCopy(workflow);\n    return callback(null, workflow);\n  }\n};\n\n\n// uuid - Workflow.uuid\n// callback - f(err, workflow)\nBackend.prototype.getWorkflow = function (uuid, callback) {\n  var self = this;\n\n  if (self.workflows[uuid]) {\n    return callback(null, deepCopy(self.workflows[uuid]));\n  } else {\n    return callback(sprintf(\n      'Workflow with uuid \\'%s\\' does not exist', uuid));\n  }\n};\n\n\n// workflow - the workflow object\n// callback - f(err, boolean)\nBackend.prototype.deleteWorkflow = function (workflow, callback) {\n  var self = this;\n\n  if (self.workflows[workflow.uuid]) {\n    return callback(null, (delete self.workflows[workflow.uuid]));\n  } else {\n    return callback(null, false);\n  }\n};\n\n// workflow - update workflow object.\n// callback - f(err, workflow)\nBackend.prototype.updateWorkflow = function (workflow, callback) {\n  var self = this;\n  if (self.workflows[workflow.uuid]) {\n    if (self._wfNames().indexOf(workflow.name) !== -1 &&\n        self.workflows[workflow.uuid].name !== workflow.name) {\n      return callback('Workflow.name must be unique. A workflow with name \"' +\n        workflow.name + '\" already exists');\n    } else {\n      self.workflows[workflow.uuid] = deepCopy(workflow);\n      return callback(null, workflow);\n    }\n  } else {\n    return callback('Workflow does not exist. Cannot Update.');\n  }\n};\n\n\n// job - Job object\n// callback - f(err, job)\nBackend.prototype.createJob = function (job, callback) {\n  var self = this;\n\n  job.created_at = job.created_at || new Date().toISOString();\n  self.jobs[job.uuid] = deepCopy(job);\n  self.queued_jobs.push(job.uuid);\n  return callback(null, job);\n};\n\n\n// uuid - Job.uuid\n// callback - f(err, job)\nBackend.prototype.getJob = function (uuid, callback) {\n  var self = this;\n\n  if (self.jobs[uuid]) {\n    return callback(null, deepCopy(self.jobs[uuid]));\n  } else {\n    return callback(sprintf(\n      'Job with uuid \\'%s\\' does not exist', uuid));\n  }\n};\n\n\n// Get a single job property\n// uuid - Job uuid.\n// prop - (String) property name\n// cb - callback f(err, value)\nBackend.prototype.getJobProperty = function (uuid, prop, cb) {\n  var self = this;\n\n  if (self.jobs[uuid]) {\n    return cb(null, self.jobs[uuid][prop]);\n  } else {\n    return cb(sprintf(\n      'Job with uuid \\'%s\\' does not exist', uuid));\n  }\n};\n\n// job - the job object\n// callback - f(err) called with error in case there is a duplicated\n// job with the same target and same params\nBackend.prototype.validateJobTarget = function (job, callback) {\n  var self = this, filtered;\n  // If no target is given, we don't care:\n  if (!job.target) {\n    return callback(null);\n  }\n\n  if (self._jobTargets().indexOf(job.target) === -1) {\n    return callback(null);\n  }\n\n  filtered = Object.keys(self.jobs).filter(function (uuid) {\n    return (\n      uuid !== job.uuid &&\n      self.jobs[uuid].target === job.target &&\n      Object.keys(job.params).every(function (p) {\n        return (self.jobs[uuid].params[p] &&\n          self.jobs[uuid].params[p] === job.params[p]);\n      }) &&\n      (self.jobs[uuid].execution === 'queued' ||\n       self.jobs[uuid].execution === 'running'));\n  });\n\n  if (filtered.length !== 0) {\n    return callback('Another job with the same target' +\n      ' and params is already queued');\n  } else {\n    return callback(null);\n  }\n};\n\n\n// Get the next queued job.\n// index - Integer, optional. When given, it'll get the job at index position\n//         (when not given, it'll return the job at position zero).\n// callback - f(err, job)\nBackend.prototype.nextJob = function (index, callback) {\n  var self = this,\n      slice = null;\n\n  if (typeof (index) === 'function') {\n    callback = index;\n    index = 0;\n  }\n\n  if (self.queued_jobs.length === 0) {\n    return callback(null, null);\n  }\n\n  slice = self.queued_jobs.slice(index, index + 1);\n\n  if (slice.length === 0) {\n    return callback(null, null);\n  } else {\n    return self.getJob(slice[0], callback);\n  }\n};\n\n// Lock a job, mark it as running by the given runner, update job status.\n// uuid - the job uuid (String)\n// runner_id - the runner identifier (String)\n// callback - f(err, job) callback will be called with error if something\n//            fails, otherwise it'll return the updated job using getJob.\nBackend.prototype.runJob = function (uuid, runner_id, callback) {\n  var self = this,\n      idx = self.queued_jobs.indexOf(uuid);\n  if (idx === -1) {\n    return callback('Only queued jobs can be run');\n  } else {\n    self.queued_jobs.splice(idx, 1);\n    self.jobs[uuid].runner_id = runner_id;\n    self.jobs[uuid].execution = 'running';\n    return callback(null, deepCopy(self.jobs[uuid]));\n  }\n};\n\n// Unlock the job, mark it as finished, update the status, add the results\n// for every job's task.\n// job - the job object. It'll be saved to the backend with the provided\n//       properties.\n// callback - f(err, job) callback will be called with error if something\n//            fails, otherwise it'll return the updated job using getJob.\nBackend.prototype.finishJob = function (job, callback) {\n  var self = this;\n  if (!self.jobs[job.uuid]) {\n    return callback(sprintf('Job with uuid \\'%s\\' does not exist', job.uuid));\n  } else if (self.jobs[job.uuid].execution !== 'running' &&\n      self.jobs[job.uuid].execution !== 'canceled') {\n    return callback('Only running jobs can be finished');\n  } else {\n    if (job.execution === 'running') {\n      job.execution = 'succeeded';\n    }\n    job.runner_id = null;\n    self.jobs[job.uuid] = deepCopy(job);\n    return callback(null, job);\n  }\n};\n\n\n// Update the job while it is running with information regarding progress\n// job - the job object. It'll be saved to the backend with the provided\n//       properties.\n// callback - f(err, job) callback will be called with error if something\n//            fails, otherwise it'll return the updated job using getJob.\nBackend.prototype.updateJob = function (job, callback) {\n  var self = this;\n\n  if (!self.jobs[job.uuid]) {\n    return callback(sprintf('Job with uuid \\'%s\\' does not exist', job.uuid));\n  } else {\n    self.jobs[job.uuid] = deepCopy(job);\n    return callback(null, job);\n  }\n};\n\n// Update only the given Job property. Intendeed to prevent conflicts with\n// two sources updating the same job at the same time, but different properties\n// uuid - the job's uuid\n// prop - the name of the property to update\n// val - value to assign to such property\n// callback - f(err) called with error if something fails, otherwise with null.\nBackend.prototype.updateJobProperty = function (\n  uuid,\n  prop,\n  val,\n  callback)\n{\n\n  var self = this;\n\n  if (!self.jobs[uuid]) {\n    return callback(sprintf('Job with uuid \\'%s\\' does not exist', uuid));\n  } else {\n    self.jobs[uuid][prop] = val;\n    return callback(null);\n  }\n};\n\n\n// Queue a job which has been running; i.e, due to whatever the reason,\n// re-queue the job. It'll unlock the job, update the status, add the\n// results for every finished task so far ...\n// job - the job Object. It'll be saved to the backend with the provided\n//       properties to ensure job status persistence.\n// callback - f(err, job) callback will be called with error if something\n//            fails, otherwise it'll return the updated job using getJob.\nBackend.prototype.queueJob = function (job, callback) {\n  var self = this;\n\n  if (!self.jobs[job.uuid]) {\n    return callback(sprintf('Job with uuid \\'%s\\' does not exist', job.uuid));\n  } else if (self.jobs[job.uuid].execution !== 'running') {\n    return callback('Only running jobs can be queued again');\n  } else {\n    job.runner_id = null;\n    job.execution = 'queued';\n    self.jobs[job.uuid] = deepCopy(job);\n    self.queued_jobs.push(job.uuid);\n    return callback(null, job);\n  }\n};\n\n\n// Get the given number of queued jobs uuids.\n// - start - Integer - Position of the first job to retrieve\n// - stop - Integer - Position of the last job to retrieve, _included_\n// - callback - f(err, jobs)\nBackend.prototype.nextJobs = function (start, stop, callback) {\n  var self = this,\n      slice = [];\n\n  if (self.queued_jobs.length === 0) {\n    return callback(null, null);\n  }\n\n  slice = self.queued_jobs.slice(start, stop + 1);\n\n  if (slice.length === 0) {\n    return callback(null, null);\n  } else {\n    return callback(null, slice);\n  }\n};\n\n\n// Register a runner on the backend and report it's active:\n// - runner_id - String, unique identifier for runner.\n// - active_at - ISO String timestamp. Optional. If none is given, current time\n// - callback - f(err)\nBackend.prototype.registerRunner = function (\n  runner_id,\n  active_at,\n  callback\n) {\n  var self = this;\n  if (typeof (active_at) === 'function') {\n    callback = active_at;\n    active_at = new Date();\n  }\n  self.runners[runner_id] = {\n    runner_id: runner_id,\n    active_at: active_at,\n    idle: false\n  };\n  return callback(null);\n};\n\n// Report a runner remains active:\n// - runner_id - String, unique identifier for runner. Required.\n// - active_at - ISO String timestamp. Optional. If none is given, current time\n// - callback - f(err)\nBackend.prototype.runnerActive = function (\n  runner_id,\n  active_at,\n  callback\n) {\n  var self = this;\n  return self.registerRunner(runner_id, active_at, callback);\n};\n\n// Get the given runner id details\n// - runner_id - String, unique identifier for runner. Required.\n// - callback - f(err, runner)\nBackend.prototype.getRunner = function (runner_id, callback) {\n  var self = this;\n  if (!self.runners[runner_id]) {\n    return callback(sprintf(\n      'Runner with uuid \\'%s\\' does not exist', runner_id));\n  } else {\n    return callback(null, self.runners[runner_id].active_at);\n  }\n};\n\n\n// Get all the registered runners:\n// - callback - f(err, runners)\nBackend.prototype.getRunners = function (callback) {\n  var self = this,\n      theRunners = {};\n\n  Object.keys(self.runners).forEach(function (uuid) {\n    theRunners[uuid] = self.runners[uuid].active_at;\n  });\n\n  return callback(null, theRunners);\n};\n\n// Set a runner as idle:\n// - runner_id - String, unique identifier for runner\n// - callback - f(err)\nBackend.prototype.idleRunner = function (runner_id, callback) {\n  var self = this;\n  if (!self.runners[runner_id]) {\n    return callback(sprintf(\n      'Runner with uuid \\'%s\\' does not exist', runner_id));\n  } else {\n    self.runners[runner_id].idle = true;\n    return callback(null);\n  }\n\n};\n\n// Check if the given runner is idle\n// - runner_id - String, unique identifier for runner\n// - callback - f(boolean)\nBackend.prototype.isRunnerIdle = function (runner_id, callback) {\n  var self = this;\n  if (!self.runners[runner_id] || (self.runners[runner_id].idle === true)) {\n    return callback(true);\n  } else {\n    return callback(false);\n  }\n};\n\n// Remove idleness of the given runner\n// - runner_id - String, unique identifier for runner\n// - callback - f(err)\nBackend.prototype.wakeUpRunner = function (runner_id, callback) {\n  var self = this;\n  if (!self.runners[runner_id]) {\n    return callback(sprintf(\n      'Runner with uuid \\'%s\\' does not exist', runner_id));\n  } else {\n    self.runners[runner_id].idle = false;\n    return callback(null);\n  }\n};\n\n// Get all jobs associated with the given runner_id\n// - runner_id - String, unique identifier for runner\n// - callback - f(err, jobs). `jobs` is an array of job's UUIDs.\n//   Note `jobs` will be an array, even when empty.\nBackend.prototype.getRunnerJobs = function (runner_id, callback) {\n  var self = this,\n      wf_runner_jobs = Object.keys(self.jobs).filter(function (uuid) {\n        return self.jobs[uuid].runner_id === runner_id;\n      });\n\n  return callback(null, wf_runner_jobs);\n};\n\n\n// Get all the workflows:\n// - callback - f(err, workflows)\nBackend.prototype.getWorkflows = function (callback) {\n  var self = this;\n\n  return callback(null, Object.keys(self.workflows).map(function (uuid) {\n    return deepCopy(self.workflows[uuid]);\n  }));\n};\n\n\n// Get all the jobs:\n// - execution - String, the execution status for the jobs to return.\n//               Return all jobs if no execution status is given.\n// - callback - f(err, jobs)\nBackend.prototype.getJobs = function (execution, callback) {\n  var self = this,\n      executions = ['queued', 'failed', 'succeeded', 'canceled', 'running'];\n\n  if (typeof (execution) === 'function') {\n    callback = execution;\n    return callback(null, Object.keys(self.jobs).map(function (uuid) {\n      return deepCopy(self.jobs[uuid]);\n    }));\n  } else if (executions.indexOf(execution) === -1) {\n    return callback('excution is required and must be one of \"' +\n      executions.join('\", \"') + '\"');\n  } else {\n    return callback(null, Object.keys(self.jobs).filter(function (uuid) {\n      return self.jobs[uuid].execution === execution;\n    }).map(function (uuid) {\n      return deepCopy(self.jobs[uuid]);\n    }));\n  }\n};\n\n\n// Add progress information to an existing job:\n// - uuid - String, the Job's UUID.\n// - info - Object, {'key' => 'Value'}\n// - callback - f(err)\nBackend.prototype.addInfo = function (uuid, info, callback) {\n  var self = this;\n\n  if (!self.jobs[uuid]) {\n    return callback('Job does not exist. Cannot Update.');\n  } else {\n    if (!util.isArray(self.jobs[uuid].info)) {\n      self.jobs[uuid].info = [];\n    }\n    self.jobs[uuid].info.push(info);\n    return callback(null);\n  }\n};\n\n\n// Get progress information from an existing job:\n// - uuid - String, the Job's UUID.\n// - callback - f(err, info)\nBackend.prototype.getInfo = function (uuid, callback) {\n  var self = this;\n\n  if (!self.jobs[uuid]) {\n    return callback('Job does not exist. Cannot get info.');\n  } else {\n    if (!util.isArray(self.jobs[uuid].info)) {\n      self.jobs[uuid].info = [];\n    }\n    return callback(null, deepCopy(self.jobs[uuid].info));\n  }\n};\n\n\nBackend.prototype._wfNames = function () {\n  var self = this,\n  wf_names = Object.keys(self.workflows).map(function (uuid) {\n    return self.workflows[uuid].name;\n  });\n  return wf_names;\n};\n\nBackend.prototype._jobTargets = function () {\n  var self = this,\n  wf_job_targets = Object.keys(self.jobs).map(function (uuid) {\n    return self.jobs[uuid].target;\n  });\n  return wf_job_targets;\n};\n"}